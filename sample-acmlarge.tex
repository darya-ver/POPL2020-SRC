%%
%% This is file `sample-acmlarge.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmlarge')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmlarge.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
% \documentclass[acmlarge]{acmart}
\documentclass[acmsmall,nonacm]{acmart}
\usepackage{listings}
%% NOTE that a single column version is required for 
%% submission and peer review. This can be done by changing
%% the \doucmentclass[...]{acmart} in this template to 
%% \documentclass[manuscript,screen,review]{acmart}
%% 
%% To ensure 100% compatibility, please check the white list of
%% approved LaTeX packages to be used with the Master Article Template at
%% https://www.acm.org/publications/taps/whitelist-of-latex-packages 
%% before creating your document. The white list page provides 
%% information on how to submit additional LaTeX packages for 
%% review and adoption.
%% Fonts used in the template cannot be substituted; margin 
%% adjustments are not allowed.
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

% Type-Guided Enumerative Program Synthesis for Higher-Order Polymorphic Language


% Good ideas:
% - pets: polymorphic enumerative type-guided synthesis
% - petsy: Polymorphic Enumerative Type-guided SYnthesis
% - petys: Polymorphic Enumerative TYpe-guided Synthesis
% - styles: S type lookups enumerative syntheiss
% http://boulter.com/anagram/

% petys
% pettys
% petice
% psyche: pol
% petsy

% Program enu
% TyGePS
% s: synthesis
% t: type-guided 
% c: component-based
% e: enumerative
% p: polymorphic
% g: guided



% TyGu
% \textsc{Tygar} 
% SYGUS 
% sy syntax

% given a agrammaer
% Gu ided
% e

% Higher-Order Polymorphic Language

% https://nutrimatic.org/?q=%22A%2BtygA%2B%22&go=Go

% stygia
% partygoers
% stygian
% apoptygma
% nantyglo
% stygionympha
% pettygrove
% ortygia


%%
%% These commands are for a JOURNAL article.
\acmJournal{POMACS}
\acmVolume{37}
\acmNumber{4}
\acmArticle{1}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
% \title{Enumerative Type-Guided Program Synthesis for Higher-Order Polymorphic Language} % \thanks{Supported by organization x.}}
\title{\textsc{Petsy}: Polymorphic Enumerative Type-Guided Synthesis}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Darya Verzhbinsky}
% \authornote{Both authors contributed equally to this research.}
\email{dverzhbi@ucsd.edu}
% \orcid{1234-5678-9012}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{University of California, San Diego}
}

\author{Daniel Wang}
\affiliation{%
  \institution{University of California, San Diego}
}
\email{daw086@ucsd.edu}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}


Consider the task of implementing a function that has the following 
description: “If I give you a function, apply it to \verb|x|. Otherwise, 
return \verb|x| unchanged.” We can translate this function description 
into a Haskell type signature as follows: 

\begin{equation}
  \label{query1}
  f:\texttt{Maybe}~(a \to a) \to x:a \to a
\end{equation}

% \begin{lstlisting}
%   f:\text{Maybe} (a \to a) \to x:a \to a
% \end{lstlisting}

\noindent where \verb|f| represents a possible function (hence the \verb|Maybe| type), and 
\verb|x| is of the same type that \verb|f| takes in and returns. A possible 
solution to this problem is:

\begin{equation}
  \label{solution1}
  \verb|\f x -> fromMaybe (\y -> y) f x|
\end{equation}

\noindent which either extracts the function from a \verb|Just| and applies it to \verb|x|, 
or applies the identity function to \verb|x| when given \verb|Nothing|
(which is the same as returning \verb|x| unchanged). As a component-based program, 
(\ref{solution1}) is idiomatic and concise and doesn't rely on if-else or pattern matching.
But finding it is potentially non-intuitive.

% We set out to build an enumerative synthesis tool that . 
% TODO this paragraph needs to be worded better.
We present \textsc{Petsy}, a tool that allows users to provide a type signature and 
optional examples, and get back a code snippet 
that consists of a composition of Haskell library functions. This allows
users to speed up their programming by using our tool to synthesize small 
Haskell programs instead of doing it themselves. 




\section{Related Work}

The problem we are exploring is polymorphic type-guided synthesis via 
enumerative search. Related problems have been explored before. 

\vspace{2mm}
\noindent \textbf{\textit{MYTH.}} \textsc{Myth} \cite{myth}
already explores enumerative search for 
type-directed synthesis, but it does not support polymorphism or typeclasses 
like we'd like \textsc{Petsy} to. 

\vspace{2mm}
\noindent \textbf{\textit{\textsc{Tygar}.}} \textsc{Tygar} \cite{tygar} uses Petri nets to 
tackle type-guided Haskell program synthesis, and is remarkable in that 
it also supports polymorphic types, typeclasses, and can check 
user-provided input-output examples. However, its encoding into Petri nets 
reduces the type system to first-order, so programs with lambdas are not in the
space of programs that \textsc{Tygar} can pull from.

\vspace{2mm}
\noindent \textbf{\textit{SYNQUID.}} \textsc{Synquid} \cite{synquid} makes 
use of an enumerative search approach, lambdas, and polymorphism. 
Its type system, however, restricts type variables (represented here with $\alpha$)
from unifying with arrow types. For example, this prevents
\texttt{Maybe} ${a \to a}$ from unifying with
${\alpha_1 \to \alpha_0 \to b}$, even though in theory
they could if \texttt{Maybe} $a$ unified with $\alpha_1$, and $a$ unified 
with $\alpha_0 \to b$.
This means certain programs that unify type variables with arrow types
are not in the search space for \textsc{Synquid}.



\section{Approach}
\label{approach}



\subsection{Synthesis Problem}

Our synthesis \textit{problem} consists of a component library, a query type,
and optional input-output examples. A \textit{solution} to the synthesis 
problem is a Haskell code snippet that has the desired type and works 
for the optionally given examples.

\subsection{Extending \textsc{Synquid}'s enumeration strategy} 

% from synquid paper:
% SYNQUID features ML-style polymorphism, where type variables are universally
% quantified at the outermost level to yield type schemas. Unlike ML, we
% restrict type variables to range only over scalars, which gives us the
% ability to determine whether a type is a scalar, even if it contains free
% type variables. We found this restriction not to be too limiting in
% practice.

\textsc{Synquid} also solves its synthesis task via top-down enumerative search.
The task it solves is similar, the only difference being that the types are
not just polymorphic -- they are liquid (refinement) types. Among other
reasons, \textsc{Synquid}'s method of supporting refinements requires it to
determine whether a type is a scalar without having to substitute its type
variables. This is made possible by restricting type variables to not unify
with arrow types. This, however, is only relevant in the context of refinement types, 
so there is no reason to have this restriction in our context. 

% Because \textsc{Petsy} employs an enumerative search method
% instead, there is no reason to have this restriction.

\textsc{Petsy} is built on top of \textsc{Synquid}, ignoring all the refinement
type logic since our synthesis task does not involve refinements. We also
change the type system by letting type variables unify with arrows.
This means \textsc{Petsy} can synthesize a wider range of programs.
Defining $::$ to mean ``has type'', one
concrete example is the query $(a \to b, a) \to b$, with components
$[\texttt{fst} :: \forall x\ldotp\forall y\ldotp (x,y)\to x, \texttt{snd} :: \forall x\ldotp\forall y\ldotp (x,y)\to y]$. The solution is \texttt{fst p
(snd p)}, which is only possible if $\forall x\ldotp\forall y\ldotp (x,y)$ in
$\texttt{fst} :: \forall x\ldotp\forall y\ldotp (x,y)\to x$,
unifies with $p :: (a \to b, a)$. Because the type variable $x$ needs to unify
with the arrow type $a \to b$, \textsc{Petsy} is able to consider the program
\texttt{fst p (snd p)} while \textsc{Synquid} cannot.

\subsection{Memoization (caching subproblems during enumeration)}

The nature of enumerative search with iterative deepening is that many
repeated subproblems are generated over the course of the search.
Redoing the same subproblems wastes a lot of time.
This makes memoization crucial to practical 
top-down enumeration, which \textsc{Myth} \cite{myth} is able to solve in a 
first-order setting.

However, memoization is mechanically difficult to deal with
when facing polymorphic type variables.
We must be careful when dealing with goals that overlap, for example:
$\alpha_0 \to \texttt{Int}$ and $\alpha_1 \to \texttt{Int}$ and
$(\texttt{Int} \to \texttt{Int}) \to \texttt{Int}$.
We discovered the following methods to resolve problems that arose due
to this complexity.

\subsubsection{Overlapping Goals}

To resolve a space explosion issue where equivalent goals
$\alpha_0 \to \texttt{Int}$ and $\alpha_1 \to \texttt{Int}$
contain the exact same programs being stored in two different locations,
the cache renames all free type variables in goals --
the first type variable becomes $\beta_0$,
the second becomes $\beta_1$, and so on.
This treats both goals as $\beta_0 \to \texttt{Int}$,
making syntactically different goals semantically equivalent.
  
\subsubsection{Preserving Unification}
The previous method with $\beta$'s introduces a small issue in program
retrieval. Consider how the program \texttt{length} of type $[\alpha_1] \to
\texttt{Int}$ solves the goal $\alpha_0 \to \texttt{Int}$. This unifies
$[\alpha_1]$ with $\alpha_0$, which is important information for
\textsc{Synquid}'s algorithm. With memoization, however, the cache stores
\texttt{length} for the more general goal $\beta_0 \to \texttt{Int}$. When
\texttt{length} is retrieved from the cache to solve $\alpha_0 \to
\texttt{Int}$, we lose the fact that $\alpha_0$ now unifies with a list, as
this information is never stored.

Instead of worrying about how to store this information,
we decided to simply unify the type of \texttt{length}, $[\alpha_1] \to \texttt{Int}$,
with the goal type $\alpha_0 \to \texttt{Int}$
at the time of retrieval. This recovers the unification information.
Although obtaining the type \texttt{length} is easy, as it is a single component,
in general we obtain the type of the retrieved program via \textit{type inference}.



\section{Results}

% table of data 
\input{results}

We tested our results on 20 benchmarks that we took from \textsc{Tygar}'s \cite{tygar} paper. 
We used the same set of 130 components in all experiments. Because \textsc{Tygar}'s search 
space was most similar to ours, we chose to compare \textsc{Petsy} with \textsc{Tygar}.
The results can be found in Table \ref{tab:results}.

% We tested our results on 20 queries with 130 components each, that were based on the queries 
% from \textsc{Tygar}'s \cite{tygar} paper, and compared \textsc{Petsy} with \textsc{Tygar}, 
% which is the tool that most resembles our own in terms of input and outputs. 
% % TODO above sentence is weird and we need to tie tygar in better 
% The results can be found in Table \ref{tab:results}.


% \subsection{\textsc{Tygar} vs. Memoization}
\vspace{2mm}
\noindent \textbf{\textit{Analysis.}} 
% TODO re-write this once we have more accurate test bench
\textsc{Petsy} and \textsc{Tygar} are comparable.
While there are some tests that \textsc{Petsy} does much \textit{better} in -- \#12 and \#17 --
and some tests that \textsc{Petsy} does much \textit{worse} in -- \#5 and \#19 -- both tools perform
about equally well (within a few seconds) on the other benchmarks.
% \textsc{Petsy} did better than \textsc{Tygar} in 9 out of the 20 tests. 
% While there are some tests that we do much better in -- \#12 and \#17 --
% and some tests that we do much worse in -- \#5 and \#19 -- both tools perform
% relatively the same and are quite comparable.

% Test \#(TODO) shows how we are able to synthesize lambdas whereas \textsc{Tygar} cannot.

These results are quite encouraging. For one, since \textsc{Petsy} takes advantage of 
lambdas and \textsc{Tygar} doesn't, \textsc{Petsy} is more expressive and therefore searches through 
more programs, yet is still competitive. We also have only implemented the most
basic form of memoization, and plan to improve upon it to make \textsc{Petsy} even
faster (see \nameref{future}).

\vspace{2mm}
\noindent \textbf{\textit{Quality of Results.}} For the most part, both \textsc{Tygar} 
and \textsc{Petsy} returned the same programs. If they didn't return the same program
(because \textsc{Petsy} found a solution using lambdas),
the programs were equivalent, so there is no significant difference in program quality between the two tools.

\section{Future Work}
\label{future}

Our memoization tool is still very basic and we think there are multiple ways in
which we can improve upon what we have:

\begin{enumerate}
  \item Re-organize our memo map to store programs first based on size, and then 
        find programs based on query. This would make lookup much faster.
  \item Take advange of sub-typing in the memo keys so that the same programs
        aren't stored multiple times. For example, all programs in goal 
        $Int \to Int$ should be in goal $\alpha_0 \to Int$. When
        we lookup $\alpha_0 \to Int$, we could first look at $Int \to Int$
        and then move on to other programs that are more general.
  % \item Explore different ways of calculating program size to see if there is 
  %       size calculation that prioritizes more desired programs. As example would be 
  %       assigning more weight to programs with uninstantiated type variables 
\end{enumerate}

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base} 



\end{document}
\endinput
%%
%% End of file `sample-acmlarge.tex'.
