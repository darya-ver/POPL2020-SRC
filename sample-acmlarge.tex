%%
%% This is file `sample-acmlarge.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmlarge')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmlarge.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
% \documentclass[acmlarge]{acmart}
\documentclass[acmsmall,nonacm]{acmart}
\usepackage{listings}
%% NOTE that a single column version is required for 
%% submission and peer review. This can be done by changing
%% the \doucmentclass[...]{acmart} in this template to 
%% \documentclass[manuscript,screen,review]{acmart}
%% 
%% To ensure 100% compatibility, please check the white list of
%% approved LaTeX packages to be used with the Master Article Template at
%% https://www.acm.org/publications/taps/whitelist-of-latex-packages 
%% before creating your document. The white list page provides 
%% information on how to submit additional LaTeX packages for 
%% review and adoption.
%% Fonts used in the template cannot be substituted; margin 
%% adjustments are not allowed.
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

% Type-Guided Enumerative Program Synthesis for Higher-Order Polymorphic Language


% Good ideas:
% - pets: polymorphic enumerative type-guided synthesis
% - petsy: Polymorphic Enumerative Type-guided SYnthesis
% - petys: Polymorphic Enumerative TYpe-guided Synthesis
% - styles: S type lookups enumerative syntheiss
% http://boulter.com/anagram/

% petys
% pettys
% petice
% psyche: pol
% petsy

% Program enu
% TyGePS
% s: synthesis
% t: type-guided 
% c: component-based
% e: enumerative
% p: polymorphic
% g: guided



% TyGu
% \textsc{Tygar} 
% SYGUS 
% sy syntax

% given a agrammaer
% Gu ided
% e

% Higher-Order Polymorphic Language

% https://nutrimatic.org/?q=%22A%2BtygA%2B%22&go=Go

% stygia
% partygoers
% stygian
% apoptygma
% nantyglo
% stygionympha
% pettygrove
% ortygia


%%
%% These commands are for a JOURNAL article.
\acmJournal{POMACS}
\acmVolume{37}
\acmNumber{4}
\acmArticle{1}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
% \title{Enumerative Type-Guided Program Synthesis for Higher-Order Polymorphic Language} % \thanks{Supported by organization x.}}
\title{\textsc{Petsy}: Polymorphic Enumerative Type-Guided Synthesis}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Darya Verzhbinsky}
% \authornote{Both authors contributed equally to this research.}
\email{dverzhbi@ucsd.edu}
% \orcid{1234-5678-9012}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{University of California, San Diego}
}

\author{Daniel Wang}
\affiliation{%
  \institution{University of California, San Diego}
}
\email{daw086@ucsd.edu}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}


Consider the task of implementing a function that has the following 
description: “If I give you a function, apply it to \verb|x|. Otherwise, 
return \verb|x| unchanged.” We can translate this function description 
into a Haskell type signature as follows: 

\begin{equation}
  \label{query1}
  f:\texttt{Maybe}~(a \to a) \to x:a \to a
\end{equation}

% \begin{lstlisting}
%   f:\text{Maybe} (a \to a) \to x:a \to a
% \end{lstlisting}

\noindent where \verb|f| represents a possible function (hence the \verb|Maybe| type), and 
\verb|x| is of the same type that \verb|f| takes in and returns. A possible 
solution to this problem is:

\begin{equation}
  \label{solution1}
  \verb|\f x -> fromMaybe (\y -> y) f x|
\end{equation}

\noindent which either extracts the function from the \verb|Maybe| and applies it to x, 
or applies the identity function to \verb|x| if the \verb|Maybe| is \verb|Nothing|
(which is the same as returning \verb|x| unchanged). As a component-based program, 
(\ref{solution1}) is idiomatic and concise and doesn't rely on pattern matching. It is potentially 
non-intuitive, though, and could be difficult for programmers to find on their own. 

% We set out to build an enumerative synthesis tool that . 
% TODO this paragraph needs to be worded better.
We present \textsc{Petsy}, a tool that allows users to provide a type signature and 
optional examples, and get back a code snippet 
that consists of a composition of Haskell library functions. This allows
users to speed up their programming by using our tool to synthesize small 
Haskell programs instead of doing it themselves. 




\section{Related Work}

The problem we are exploring is polymorphic type-guided synthesis via 
enumerative search. Related problems have been explored before. 

\vspace{2mm}
\noindent \textbf{\textit{MYTH.}} \textsc{Myth} \cite{myth}
already explores enumerative search for 
type-directed synthesis, but it does not support polymorphism or typeclasses 
like we'd like \textsc{Petsy} to. 

\vspace{2mm}
\noindent \textbf{\textit{\textsc{Tygar}.}} \textsc{Tygar} \cite{tygar} uses Petri nets to 
tackle type-guided Haskell program synthesis, and is remarkable in that 
it also supports polymorphic types, typeclasses, and can check 
user-provided input-output examples. Because of its use of Petri nets, 
however, it has to reduce everything to first order, meaning that 
it can't make use of lambdas, which limits the space of programs that
\textsc{Tygar} can pull from.

\vspace{2mm}
\noindent \textbf{\textit{SYNQUID.}} \textsc{Synquid} \cite{synquid} makes 
use of an enumerative search approach, lambdas, and polymorphism. 
Its type system, however, restricts type variables (represented here with $\alpha$)
from unifying with arrow types. This prevents, for example, 
\texttt{Maybe} ${a \to a}$ 
and ${\alpha_1 \to \alpha_0 \to b}$ from unifying, even though in theory
they could if \texttt{Maybe} $a$ unified with $\alpha_1$, and $a$ unfied 
with $\alpha_0 \to b$. This leads to some programs being unreachable
and, in the context of higher-order components, limits the search space. 



\section{Approach}
\label{approach}



\subsection{Synthesis Problem}

Our synthesis \textit{problem} consists of a component library, a query type,
and optional input-output examples. A \textit{solution} to the synthesis 
problem is a Haskell code snippet that has the desired type and works 
for the optionally given examples.

\subsection{Extending \textsc{Synquid}'s enumeration strategy} 

% from synquid paper:
% SYNQUID features ML-style polymorphism, where type variables are universally
% quantified at the outermost level to yield type schemas. Unlike ML, we
% restrict type variables to range only over scalars, which gives us the
% ability to determine whether a type is a scalar, even if it contains free
% type variables. We found this restriction not to be too limiting in
% practice.

\textsc{Synquid} also solves itsw synthesis task via top-down enumerative search.
The task it solves is similar, the only difference being that the types are
not just polymorphic -- they are liquid (refinement) types. Among other
reasons, \textsc{Synquid}'s method of supporting refinements requires it to
determine whether a type is a scalar without having to substitute its type
variables. This is made possible by restricting type variables to not unify
with arrow types. Because \textsc{Petsy} employs an enumerative search method
instead, there is no reason to have this restriction.

Petsy is built on top of Synquid, ignoring all the refinement type logic since
our synthesis task does not involve refinements. We also change the type system
such that type variables are no longer restricted to unify only with scalar types
-- type variables can now unify with arrows.
This means \textsc{Petsy} can synthesize a wider range of programs. One
concrete example is the query $(a \to b, a) \to b$, with components
$[\texttt{fst}$ of type $\forall x\ldotp\forall y\ldotp (x,y)\to x, \texttt{snd}$
of type $\forall x\ldotp\forall y\ldotp (x,y)\to y]$. The solution is \texttt{fst p
(snd p)}, which is only possible if $\forall x\ldotp\forall y\ldotp (x,y)$ in
the type of the component $\texttt{fst}$, $\forall x\ldotp\forall y\ldotp (x,y)\to x$,
unifies with the type of $p$, $(a \to b, a)$. Because the type variable $x$ needs to unify
with the arrow type $a \to b$, \textsc{Petsy} is able to synthesize this
while \textsc{Synquid} cannot.

\subsection{Memoization (caching subproblems during enumeration)}

Because of its enumerative and iterative deepening qualities, \textsc{Petsy} 
generates many repeated subproblems
over the course of the search, wasting a lot of time redoing searches it has
already done. This makes memoization crucial to practical 
top-down enumeration, which \textsc{Myth} \cite{myth} is able to solve in a 
first-order setting.

In our polymorphic context, however, memoization is non-trivial, as goal types
can now contain free type variables. 

Memoization is mechanically difficult to deal with in a polymorphic setting,
because we have to be careful when dealing with goals that overlap (example:
$\alpha_0 \to \texttt{Int}$ and $\alpha_1 \to \texttt{Int}$ and
$(\texttt{Int} \to \texttt{Int}) \to \texttt{Int}$).
However, we discovered that the following methods resolve these problems.

% \begin{enumerate}
%   \item 

\subsubsection{Overlapping Goals}

To resolve a space explosion issue where equivalent goals
$\alpha_0 \to \texttt{Int}$ and $\alpha_1 \to \texttt{Int}$
contain the exact same programs being stored in two different locations,
the cache renames all free type variables in goals --
the first type variable becomes $\beta_0$,
the second becomes $\beta_1$, and so on.
This treats both goals as $\beta_0 \to \texttt{Int}$,
making syntactically different goals semantically equivalent.
  
  % \item 
\subsubsection{Preserving Unification}
The previous method with $\beta$'s introduces a small issue in program retrieval.
Consider how
the program \texttt{length} of type $[\alpha_1] \to \texttt{Int}$
solves the goal $\alpha_0 \to \texttt{Int}$.
This unifies $[\alpha_1]$ with $\alpha_0$, which is important information for
\textsc{Synquid}'s algorithm.
With memoization, however, \texttt{length} gets stored in the cache for the goal
$\beta_0 \to \texttt{Int}$.
When \texttt{length} is retrieved from the cache to solve $\alpha_0 \to \texttt{Int}$,
we lose the fact that $\alpha_0$ now unifies with a list,
as this information is never stored.

Instead of worrying about how to store this information,
we decided to simply unify the type of \texttt{length}, $[\alpha_1] \to \texttt{Int}$,
with the goal type $\alpha_0 \to \texttt{Int}$
at the time of retrieval. This recovers the unification information.
Obtaining the type of the retrieved program is easy when the program is a single
% component. We use \textit{type inference} to obtain the type so that it can 

component, but it is harder for larger programs. So in general, we obtain the type 
with \textit{type inference}.
% TODO still don't like this, but let's stop stressing over a single sentence


. We use \textit{type inference} to obtain the type so that it can 
% be generalized across single and multi-component programs. 
work for single and multi-component programs. 

% To keep in consistent across single and multiple component programs
% (like \texttt{map length}), we use \textit{type inference} to obtain the type.


% To keep in consistent across single and multiple component programs
% can i reaplce this with
% In general, k

% , it becomes more complicated when programs have more than a single component. 
% In these situations, like \texttt{map length}, we will use \textit{type inference} to 
% obtain the type.

% % i tried to make it sound like single component is not a special case
% % i think i failed lol single component still sounded like it was special
% hmmm kk
% lemme redo 
% but we can do this for programs in general (like \texttt{map length})
% by obtaining the type with type inference.
  
% \end{enumerate}





% because of free variables, it's important to know how the free variables are changed
% after generation of program. instead of worrying about how to store this information
% int he map, we decided to simply infer the types after retrieval

% \vspace{2mm}
% \noindent \textbf{\textit{Redundancy.}} In \textsc{Petsy}, free variables 
% are represented as $\alpha$'s. If you look at 2 goals, $\alpha_0 \to Int$ 
% and $\alpha_1 \to Int$, even though they are syntactically different (they have 
% subscripts), 
% they are semantically equivalent because each is essentially saying "I want 
% a program that takes in anything and returns an \texttt{Int}". Because 
% of their semantic difference, however, they would be stored in 2 different 
% locations in the memo map, resulting in the exact same programs being stored
% in 2 different locations. 
% How can we avoid this and make these two goals equivalent?

% To resolve this, we rename any incoming free type variables 
% to be "fresh" $\beta$'s before using them as the map lookup key. That way, if 
% two different goals with free variables come in, say $\alpha_0 \to Int$ and 
% $\alpha_1 \to Int$, they will each be renamed to $\beta_0 \to Int$ 
% and $\beta_0 \to Int$, meaning that they will hit the same entry in the map,
% despite having different original names.

% THIS PART is the same as your first list item IMO ^ 





% \vspace{2mm}
% \noindent \textbf{\textit{Type Clashes.}} % todo dif title name

% % When \textsc{Petsy} synthesizes a function application, it tries to match
% % the function type with its arguments. For example, if the function is type
% % a -> b, then the type of the argument must unify with a. An issue arises if
% % we retrieve this argument from the memo map -- its argument must unify with a


% % This may cause an issue with
% % retrieving from memo because the type of the program we 


% ---

% Another issue comes into play when we're trying to synthesize 
% arguments to a component. This is when the type of the component 
% comes into play, as we need it to know the type of its arguments. 
% One solution to this is to simply store the type along with the 
% program in the memo map. The presence of type variables in the stored 
% type will cause type clashes, however, causing this naive solution 
% to have undesired outcomes. 

% Say, for example, we generate and store a program whose type still contains 
% a free variable, $\alpha$. And let's say later in the search, we 
% retrieve this program and use its stored type as the actual type. The 
% problem arises when at \textit{that second point in the search}, $\alpha$
% is used in a type query that was never supposed to linked to this retrieved
% program, but now is because the stored type contains $\alpha$.

% Say, for example, we generate and store a program whose type still contains 
% a free variable, $\alpha_3$. And let's say later in the search, we 
% retrieve this program and use its stored type as the actual type. The 
% problem arises when at \textit{that second point in the search}, $\alpha_3$
% is used in a type query that was never supposed to linked to this retrieved
% program, but now is because the stored type contains $\alpha_3$ 
% ($\alpha_3$ is reused because of backtracking in our search allowing for 
% duplicate free variable names in order to avoid massive names like $\alpha_{75000}$). 


% $\alpha_3$ in 
% its type, and at at the time $\alpha_3$ is 
% free. But let's 
% When we retrieve this program later in the search, 
% $\alpha_3$ might now be in use in one of the arguments that wasn't
% originally tied to the component, and we would be linking 
% the two free variables unintentially and creating a clash. 

% To avoid this clash, instead of relying on the stored type, which in this case
% depends on $\alpha$, we infer the type
% of the retrieved program by generating a "fresh" type, $A_0$ for example, 
% independantly from the stored type, so that 
% the stored $\alpha$ can be discarded and there is no longer a conflict 
% with the current $\alpha$.




\section{Results}

% table of data 
\input{results}

We tested our results on 20 benchmarks that we took from \textsc{Tygar}'s \cite{tygar} paper. 
We used the same set of 130 components in all experiments. Because \textsc{Tygar}'s search 
space was most similar to ours, we chose to compare \textsc{Petsy} with \textsc{Tygar}.
The results can be found in Table \ref{tab:results}.

% We tested our results on 20 queries with 130 components each, that were based on the queries 
% from \textsc{Tygar}'s \cite{tygar} paper, and compared \textsc{Petsy} with \textsc{Tygar}, 
% which is the tool that most resembles our own in terms of input and outputs. 
% % TODO above sentence is weird and we need to tie tygar in better 
% The results can be found in Table \ref{tab:results}.


% \subsection{\textsc{Tygar} vs. Memoization}
\vspace{2mm}
\noindent \textbf{\textit{Analysis.}} 
% TODO re-write this once we have more accurate test bench
\textsc{Petsy} did better than \textsc{Tygar} in 9 out of the 20 tests. 
While there are some tests that we do much better in -- \#12 and \#17 --
and some tests that we do much worse in -- \#5 and \#19 -- both tools perform
relatively the same and are quite comparable.

% Test \#(TODO) shows how we are able to synthesize lambdas whereas \textsc{Tygar} cannot.

These results are quite encouraging. For one, since \textsc{Petsy} takes advantage of 
lambdas and \textsc{Tygar} doesn't, \textsc{Petsy} is more expressive and therefore searches through 
more programs, yet is still competitive. We also have only implemented the most
basic form of memoization, and plan to improve upon it to make \textsc{Petsy} even
faster (see \nameref{future}).

\vspace{2mm}
\noindent \textbf{\textit{Quality of Results.}} For the most part, both \textsc{Tygar} 
and \textsc{Petsy} returned the same programs. If they didn't return the same program,
the programs were equivalent, so the differences between the results of the two
tools is insignificant. 

\section{Future Work}
\label{future}

Our memoization tool is still very basic and we think there are multiple ways in
which we can improve upon what we have:

\begin{enumerate}
  \item Re-organize our memo map to store programs first based on size, and then 
        find programs based on query. This would make lookup much faster.
  \item Take advange of sub-typing in the memo keys so that the same programs
        aren't stored multiple times. For example, all programs in goal 
        $Int \to Int$ should be in goal $\alpha_0 \to Int$. When
        we lookup $\alpha_0 \to Int$, we could first look at $Int \to Int$
        and then move on to other programs that are more general.
  % \item Explore different ways of calculating program size to see if there is 
  %       size calculation that prioritizes more desired programs. As example would be 
  %       assigning more weight to programs with uninstantiated type variables 
\end{enumerate}

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base} 



\end{document}
\endinput
%%
%% End of file `sample-acmlarge.tex'.
