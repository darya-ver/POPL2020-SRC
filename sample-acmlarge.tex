%%
%% This is file `sample-acmlarge.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmlarge')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmlarge.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
% \documentclass[acmlarge]{acmart}
\documentclass[acmsmall,nonacm]{acmart}
\usepackage{listings}
%% NOTE that a single column version is required for 
%% submission and peer review. This can be done by changing
%% the \doucmentclass[...]{acmart} in this template to 
%% \documentclass[manuscript,screen,review]{acmart}
%% 
%% To ensure 100% compatibility, please check the white list of
%% approved LaTeX packages to be used with the Master Article Template at
%% https://www.acm.org/publications/taps/whitelist-of-latex-packages 
%% before creating your document. The white list page provides 
%% information on how to submit additional LaTeX packages for 
%% review and adoption.
%% Fonts used in the template cannot be substituted; margin 
%% adjustments are not allowed.
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

% Type-Guided Enumerative Program Synthesis for Higher-Order Polymorphic Language


% Good ideas:
% - pets: polymorphic enumerative type-guided synthesis
% - petsy: Polymorphic Enumerative Type-guided SYnthesis
% - petys: Polymorphic Enumerative TYpe-guided Synthesis
% - styles: S type lookups enumerative syntheiss
% http://boulter.com/anagram/

% petys
% pettys
% petice
% psyche: pol
% petsy

% Program enu
% TyGePS
% s: synthesis
% t: type-guided 
% c: component-based
% e: enumerative
% p: polymorphic
% g: guided



% TyGu
% \textsc{Tygar} 
% SYGUS 
% sy syntax

% given a agrammaer
% Gu ided
% e

% Higher-Order Polymorphic Language

% https://nutrimatic.org/?q=%22A%2BtygA%2B%22&go=Go

% stygia
% partygoers
% stygian
% apoptygma
% nantyglo
% stygionympha
% pettygrove
% ortygia


%%
%% These commands are for a JOURNAL article.
\acmJournal{POMACS}
\acmVolume{37}
\acmNumber{4}
\acmArticle{1}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
% \title{Enumerative Type-Guided Program Synthesis for Higher-Order Polymorphic Language} % \thanks{Supported by organization x.}}
\title{\textsc{Petsy}: Polymorphic Enumerative Type-Guided Synthesis}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Darya Verzhbinsky}
% \authornote{Both authors contributed equally to this research.}
\email{dverzhbi@ucsd.edu}
% \orcid{1234-5678-9012}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{University of California, San Diego}
}

\author{Daniel Wang}
\affiliation{%
  \institution{University of California, San Diego}
}
\email{daw086@ucsd.edu}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}


Consider the task of implementing a function that has the following 
description: “If I give you a function, apply it to \verb|x|. Otherwise, 
return \verb|x| unchanged.” We can translate this function description 
into a Haskell type signature as follows: 

\begin{equation}
  \label{query1}
  f:\texttt{Maybe}~(a \to a) \to x:a \to a
\end{equation}

% \begin{lstlisting}
%   f:\text{Maybe} (a \to a) \to x:a \to a
% \end{lstlisting}

\noindent where \verb|f| represents a possible function (hence the \verb|Maybe| type), and 
\verb|x| is of the same type that \verb|f| takes in and returns. A possible 
solution to this problem is:

\begin{equation}
  \label{solution1}
  \verb|\f x -> fromMaybe (\y -> y) f x|
\end{equation}

\noindent which either extracts the function from the \verb|Maybe| and applies it to x, 
or applies the identity function to \verb|x| if the \verb|Maybe| is \verb|Nothing|
(which is the same as returning \verb|x| unchanged). As a component based program,
it is idiomatic and concise, and doesn't rely on pattern matching.  
It is potentially non-intuitive, though, and could be difficult 
for programmers to find on their own. 


% We set out to build an enumerative synthesis tool that . 
% TODO this paragraph needs to be worded better.
We present \textsc{Petsy}, a tool that allows users to provide a type signature and 
optional examples, and get back a code snippet 
that consists of a composition of Haskell library functions. This allows
users to speed up their programming by using our tool to synthesize small 
Haskell programs instead of doing it themselves. 




\section{Related Work}

The problem we are exploring is polymorphic type-guided synthesis via 
enumerative search. Related problems have been explored before. 

\vspace{2mm}
\noindent \textbf{\textit{MYTH.}} \textsc{Myth} \cite{myth}
already explores enumerative search for 
type-directed synthesis, but it does not support polymorphism or typeclasses 
like we'd like \textsc{Petsy} to. 

\vspace{2mm}
\noindent \textbf{\textit{\textsc{Tygar}.}} \textsc{Tygar} \cite{tygar} uses Petri nets to 
tackle type-guided Haskell program synthesis, and is remarkable in that 
it also supports polymorphic types, typeclasses, and can check 
user-provided input-output examples. Because of its use of Petri nets, 
however, it has to reduce everything to first order, meaning that 
it can't make use of lambdas, which limits the space of programs that
\textsc{Tygar} can pull from.

\vspace{2mm}
\noindent \textbf{\textit{SYNQUID.}} \textsc{Synquid} \cite{synquid} makes 
use of an enumerative search approach, lambdas, and polymorphism. 
Its type system, however, restricts type variables
from unifying with arrow types. This prevents, for example, 
\texttt{Maybe} ${a \to a}$ 
and ${\alpha_1 \to \alpha_0 \to b}$ from unifying, even though in theory
they could if \texttt{Maybe} $a$ unified with $\alpha_1$, and $a$ unfied 
with $\alpha_0 \to b$. This leads to some programs being unreachable
and, in the context of higher-order components, limits the search space. 



\section{Approach}
\label{approach}



\subsection{Synthesis Problem}

Our synthesis \textit{problem} consists of a component library, a query type,
and optional input-output examples. A \textit{solution} to the synthesis 
problem is a Haskell code snippet that has the desired type and works 
for the optionally given examples.


\subsection{Extending \textsc{Synquid}'s enumeration strategy} 

\textsc{Petsy} builds upon \textsc{Synquid}, which solves its synthesis task 
by performing a top-down enemerative search and taking advantage of
refinement types that are included in the initial type query. 

% \textsc{Synquid} synthesizes function applications in the following way. 
% Given a goal $?? :: T$ that is an application, split it into two 
% goals for the function and argument: $(?? :: \alpha \to T)$ and 
% $(?? :: \alpha)$. Repeating this process in the first goal lets us 
% use functions that take in more arguments:

% \[ (?? :: \alpha_0 \to T) (?? :: \alpha_0) \]
% \[ (?? :: \alpha_1 \to \alpha_0 \to T) (?? :: \alpha_1) (?? :: \alpha_0) \]
% \[ (?? :: \alpha_2 \to \alpha_1 \to \alpha_0 \to T) (?? :: \alpha_2) (?? :: \alpha_1) (?? :: \alpha_0) \]

% This could repeat forever. To ensure search terminates, the components 
% decide the cutoff point: if the longest arrow type in the components is 
% $a \to b \to c \to d$, then we stop splitting the goal once we see 
% $\alpha_2 \to \alpha_1 \to \alpha_0 \to T$.

% TODO remove the cutoff discussion

However, \textsc{Synquid} doesn't support cases where type variables are
instantiated with  arrow types. One concrete example is the query $(a \to b,
a) \to b$  with components $[\texttt{fst}, \texttt{snd}]$. The solution is 
\texttt{fst p (snd p)}, which uses \texttt{fst} as a two-argument function, 
which means \texttt{fst} must have filled the goal $\alpha_1 \to \alpha_0 \to
T$. However, \texttt{fst} and \texttt{snd} are one-argument functions --  the
cutoff is $\alpha_0 \to T$, so we never end up considering the goal $\alpha_1
\to \alpha_0 \to T$.

Our solution is to use iterative deepening on the size of programs, 
rather than depth first search. Because we only enumerate programs up 
to a certain size anyways, we can be rid of the decision of ``where to 
stop splitting the goal''.

We also replace the measure of program size with ``number of components'' 
rather than ``recursion depth'', because size tends to generate deeper 
programs earlier, and deep programs like \texttt{f (g (h x))} tend to 
be more programmer-relevant than flat programs.



\subsection{Memoization (caching subproblems during enumeration)}

Because of its enumerative and iterative deepening qualities, \textsc{Petsy} 
generates many repeated subproblems
over the course of the search, wasting a lot of time redoing searches it has
already done. This makes memoization crucial to practical 
top-down enumeration, which \textsc{Myth} \cite{myth} was able to solve in a 
first-order setting.
In our polymorphic context, however, memoization is non-trivial, as goal types can now contain free 
type variables. This causes the following issues.

\vspace{2mm}
\noindent \textbf{\textit{Redundancy.}} In \textsc{Petsy}, free variables 
are represented as $\alpha$'s. If you look at 2 goals, $\alpha_0 \to Int$ 
and $\alpha_1 \to Int$, even though they are syntactically different because of the subscripts,
they are semantically equivalent because each is essentially saying "I want 
a program that takes in anything and returns an \texttt{Int}". Because 
of their semantic difference, however, they would be stored in 2 different 
locations in the memo map, resulting in the exact same programs being stored
in 2 different locations. 
How can we avoid this and make these two goals equivalent?

To resolve this, we rename any incoming free type variables 
to be "fresh" $\beta$'s before using them as the map lookup key. That way, if 
two different goals with free variables come in, say $\alpha_0 \to Int$ and 
$\alpha_1 \to Int$, they will each be renamed to $\beta_0 \to Int$ 
and $\beta_0 \to Int$, meaning that they will hit the same entry in the map,
despite having different original names.

\vspace{2mm}
\noindent \textbf{\textit{Type unificiation clashes.}} 
% TODO reword
Another issue comes into play when we're trying to synthesize 
arguments to a component and the component's type contains 
free variables (that are yet to be unified with a concrete
type). 
% Another issue is that if we were to use the stored program type, which 
% could contain free variables, as the type of the program, we would run into 
% type clashes when trying to synthesize the program's arguments. 
Say, for example, we generate and store a program that has $\alpha_3$ in 
its type, and at at the time $\alpha_3$ is 
free. When we retrieve this program later in the search, 
$\alpha_3$ might now be in use for something else, and we would be linking 
the two free variables unintentially and creating a clash. 

To avoid this clash, instead of relying on the stored type, which in this case
depends on $\alpha_3$, we infer the type
of the retrieved program by generating a "fresh" type, $A_0$ for example, 
independantly from the stored type, so that 
the stored $\alpha_3$ can be discarded and there is no longer a conflict 
with the current $\alpha_3$.


% Now that 
% the map supports the 2 different goals $\alpha_0 \to Int$ and 
% $\alpha_1 \to Int$ hitting the same entry in the map, there's an issue 
% of what the type of the stored program is. Let's say that when we
% synthesized $\alpha_0 \to Int$, there was no entry in the map and 
% it synthesized it from scratch. It got the following program back


% length :: [tau0] -> Int
% goal: alpha0 -> Int 
% alpha0 ~ [tau0]


% To resolve the \textit{type unification clashes}, a potential solution could be to just store
% the program's type in the memo map's value along with the program. This
% causes issues, however, when the program's type depends on the free variables
% that are part of the goal. Because of our solution to redundancy, 
% we rename these free variables from $\alpha$'s to $\beta$'s, making the reference
% the these free variables in the type meaningless outside the scope of the memo map.


% ---

% Consider the query

%     (a -> Int) -> Int

%     f _ = 0
    
% so we have (arg0 :: <a> . a -> Int) with goal type Int
% split goal to get (?? :: alpha0 -> Int) (?? :: alpha0)
% now arg0 fills in the first hole, so it gets stored in memo
% as (arg0 :: alpha0 -> Int)
% arg0 <- getUnified 
% Program {

%   typeOf = a -> Int
% }

% length :: [tau0] -> Int 
% goal   :: alpha0 -> Int 

% length :: [tau0] -> Int 
%           alpha0 -> Int


% reverse :: tau0 . [tau0] -> [tau0]
% goal: alpha0 -> Int  
% alpha0 ~ [Int]

% memo map
% alpha0 -> Int  ==>   head :: [tau0] -> tau0

% head (head xs)
% ( ) ( ) ( )


% Quota 4
% =========


% dfs has been entered 78 times
% memo map looks like:
% {
%   (IMode | quota 1 | must have [("arg0",Either (a) ((Either (a) (b))))] | ?? :: Either (beta1) (beta0)) ==> [
%     arg0 :: Either (a) ((Either (a) (b)))
%     ]
%   (IMode | quota 1 | must have [] | ?? :: (beta0 -> Either (a) (b))) ==> [
%     Data.Either.Left :: (a -> Either (a) (b))
%     ]
%   (IMode | quota 1 | must have [] | ?? :: (beta0 -> Either (a) (b))) ==> [
%     Data.Either.Right :: (b -> Either (a) (b)), Data.Either.Left :: (a -> Either (a) (b))
%     ]
%   (EMode | quota 4 | must have [("arg0",Either (a) ((Either (a) (b))))] | ?? :: Either (a) (b)) ==> [
%     Data.Either.either Data.Either.Right Data.Either.Left arg0 :: Either (a) (b)
%     ]
%   (EMode | quota 1 | must have [] | ?? :: (beta0 -> Either (a) (b))) ==> [
%     Data.Either.Right :: (b -> Either (a) (b)), Data.Either.Left :: (a -> Either (a) (b))
%     ]
%   (EMode | quota 3 | must have [] | ?? :: (beta0 -> Either (a) (b))) ==> [
%     Data.Either.either Data.Either.Right Data.Either.Left :: (Either (tau2) (tau1) -> Either (a) (b)), Data.Either.either Data.Either.Left Data.Either.Left :: (Either (tau2) (tau1) -> Either (a) (b))
%     ]
%   (EMode | quota 2 | must have [] | ?? :: (beta1 -> (beta0 -> Either (a) (b)))) ==> [
%     Data.Either.either Data.Either.Right :: (((tau1 -> Either (a) (b))) -> (Either (tau2) (tau1) -> Either (a) (b))), Data.Either.either Data.Either.Left :: (((tau1 -> Either (a) (b))) -> (Either (tau2) (tau1) -> Either (a) (b)))
%     ]
%   (EMode | quota 1 | must have [] | ?? :: (beta2 -> (beta1 -> (beta0 -> Either (a) (b))))) ==> [
%     Data.Either.either :: (((tau2 -> Either (a) (b))) -> (((tau1 -> Either (a) (b))) -> (Either (tau2) (tau1) -> Either (a) (b))))
%     ]
% }

% f :: tau0 -> Int 
% goal :: alpha0 -> Int

% tau0 -> [tau0]

% alpha0 -> [Int]

% (f :: alpha0 -> alpha1 -> ___ ) (alpha0) (alpha1)

% sub      tau0 -> Int ??? or alpha0 -> Int 










% maybe later we encounter this same goal (Int) as a subgoal.

% if we apply a function f of type Int -> alpha0 -> Int
% then the goal becomes
% f (?? :: Int) (?? :: alpha0)

% then when we split, we get

% f ((?? :: alpha1 -> Int) (?? :: alpha1)) (?? :: alpha0)

% using memo map, we get arg0 :: alpha0 -> Int



% ----
% originally: alpha0 -> Int
% store program: alpha0 -> Int

% new goal: alpha1 -> Int
% retrieve, type will be alpha0 -> Int

% why inference if we can just do  (alpha1 -> Int) ~ (alpha0 -> Int)?
% because consider this goal:

% (_ :: alpha1 -> Int) (_ :: alpha1) (_ :: alpha0)

% if we retrieve (f x :: alpha0 -> Int) from the memo map and unify
%   (alpha1 -> Int) ~ (alpha0 -> Int)
%   then we erroneously unify the (_ :: alpha1) (_ :: alpha0) outside of our goal

% solution is to retrieve (f x :: alpha0 -> Int) and then magically rename its
% type variables to something that doesn't clash with the outside

% why inference if we could just choose to not store alpha0 -> Int,
% instead always store whatever alpha0 maps to
% so something like [tau0] -> Int
% (length (length ... ))

% ==> [fromJust :: Maybe tau0 -> tau0]


% use type inference for this purpose! we get something like: (f x :: A0 -> Int)

% and now we can unify (alpha1 -> Int) ~ (A0 -> Int) and have no problems :)
% ----



% To resolve the first issue, we use type inference to infer the type of 
% the retrieved programs as if it was an existing component. For example, if we
% retrieve a program \verb|length|, 

% - type inference is used in our program this way
% - it happens when we get a program from memo map
% - however, it will have type variables that need to unify with other type variables
% -      (_ :: alpha0 -> b) (_ :: alpha0)
% -      
% - e.g. (f :: a->b) (_ :: a) , when solving the second goal with memo map
% -- we could get (g x) :: beta0, which we infer to become (g x) :: a






\section{Results}

% table of data 
\input{results}


% TODO make sure that this is correct (where queries are from)
% TODO say how many components are used in the tests
We tested our results on 20 queries, that were based on the queries 
from \textsc{Tygar}'s \cite{tygar} paper and ${\lambda^2}$ \cite{lambda2}, and 
compared \textsc{Petsy} with \textsc{Tygar}, 
which is the tool that most resembles our own in terms of input and outputs. 
% TODO above sentence is weird and we need to tie tygar in better 
The results can be found in Table \ref{tab:results}.


% \subsection{\textsc{Tygar} vs. Memoization}
\vspace{2mm}
\noindent \textbf{\textit{Analysis.}} 
% TODO re-write this once we have more accurate test bench
\textsc{Tygar} did better than \textsc{Petsy} in (TODO) out of the 20 tests. 
For most of the tests, the difference between the 2 tools is quite small. There
are additionally some tests that we do much better in (TODO list them)
and some tests that we do much worse in (TODO list them).
Test \#(TODO) shows how we are able to synthesize lambdas whereas \textsc{Tygar} cannot.

These results are quite encouraging. For one, since \textsc{Petsy} takes advantage of 
lambdas and \textsc{Tygar} doesn't, \textsc{Petsy} is more expressive and therefore searches through 
more programs, yet is still competitive. We also have only implemented the most
basic form of memoization, and plan to improve upon it to make \textsc{Petsy} even
faster (see \nameref{future}).

\vspace{2mm}
\noindent \textbf{\textit{Quality of Results.}} For the most part, both \textsc{Tygar} 
and \textsc{Petsy} returned the same programs. If they didn't return the same program,
the programs were equivalent, so the differences between the results of the two
tools is insignificant. 

\section{Future Work}
\label{future}

Our memoization tool is still very basic and we think there are multiple ways in
which we can improve upon what we have:

\begin{enumerate}
  \item Re-organize our memo map to store programs first based on size, and then 
        find programs based on query. This would make lookup much faster.
  \item Take advange of sub-typing in the memo keys so that the same programs
        aren't stored multiple times. For example, all programs in goal 
        $Int \to Int$ should be in goal $\alpha_0 \to Int$. When
        we lookup $\alpha_0 \to Int$, we could first look at $Int \to Int$
        and then move on to other programs that are more general.
  % \item Explore different ways of calculating program size to see if there is 
  %       size calculation that prioritizes more desired programs. As example would be 
  %       assigning more weight to programs with uninstantiated type variables 
\end{enumerate}

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base} 



\end{document}
\endinput
%%
%% End of file `sample-acmlarge.tex'.
