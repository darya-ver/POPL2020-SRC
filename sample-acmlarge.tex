%%
%% This is file `sample-acmlarge.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmlarge')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmlarge.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
% \documentclass[acmlarge]{acmart}
\documentclass[acmsmall,nonacm]{acmart}
\usepackage{listings}
%% NOTE that a single column version is required for 
%% submission and peer review. This can be done by changing
%% the \doucmentclass[...]{acmart} in this template to 
%% \documentclass[manuscript,screen,review]{acmart}
%% 
%% To ensure 100% compatibility, please check the white list of
%% approved LaTeX packages to be used with the Master Article Template at
%% https://www.acm.org/publications/taps/whitelist-of-latex-packages 
%% before creating your document. The white list page provides 
%% information on how to submit additional LaTeX packages for 
%% review and adoption.
%% Fonts used in the template cannot be substituted; margin 
%% adjustments are not allowed.
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

% Type-Guided Enumerative Program Synthesis for Higher-Order Polymorphic Language


% Good ideas:
% - pets: polymorphic enumerative type-guided synthesis
% - petsy: Polymorphic Enumerative Type-guided SYnthesis
% - petys: Polymorphic Enumerative TYpe-guided Synthesis
% - styles: S type lookups enumerative syntheiss
% http://boulter.com/anagram/

% petys
% pettys
% petice
% psyche: pol
% petsy

% Program enu
% TyGePS
% s: synthesis
% t: type-guided 
% c: component-based
% e: enumerative
% p: polymorphic
% g: guided



% TyGu
% \textsc{Tygar} 
% SYGUS 
% sy syntax

% given a agrammaer
% Gu ided
% e

% Higher-Order Polymorphic Language

% https://nutrimatic.org/?q=%22A%2BtygA%2B%22&go=Go

% stygia
% partygoers
% stygian
% apoptygma
% nantyglo
% stygionympha
% pettygrove
% ortygia


%%
%% These commands are for a JOURNAL article.
\acmJournal{POMACS}
\acmVolume{37}
\acmNumber{4}
\acmArticle{1}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
% \title{Enumerative Type-Guided Program Synthesis for Higher-Order Polymorphic Language} % \thanks{Supported by organization x.}}
\title{\textsc{Petsy}: Polymorphic Enumerative Type-guided Synthesis}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Darya Verzhbinsky}
% \authornote{Both authors contributed equally to this research.}
\email{dverzhbi@ucsd.edu}
% \orcid{1234-5678-9012}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{University of California, San Diego}
}

\author{Daniel Wang}
\affiliation{%
  \institution{University of California, San Diego}
}
\email{daw086@ucsd.edu}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}


Consider the task of implementing a function that has the following 
description: “If I give you a function, apply it to \verb|x|. Otherwise, 
return \verb|x| unchanged.” We can translate this function description 
into a Haskell type signature as follows: 

\begin{equation}
  \label{query1}
  f:\texttt{Maybe}~(a \to a) \to x:a \to a
\end{equation}

% \begin{lstlisting}
%   f:\text{Maybe} (a \to a) \to x:a \to a
% \end{lstlisting}

\noindent where \verb|f| represents a possible function (hence the \verb|Maybe| type), and 
\verb|x| is of the same type that \verb|f| takes in and returns. A possible 
solution to this problem is:

\begin{equation}
  \label{solution1}
  \verb|\f x -> fromMaybe (\y -> y) f x|
\end{equation}

\noindent which either extracts the function from the \verb|Maybe| and applies it to x, 
or applies the identity function to \verb|x| if the \verb|Maybe| is \verb|Nothing|
(which is the same as returning \verb|x| unchanged). As a component based program,
it is idiomatic and concise, and doesn't rely on pattern matching.  
It is potentially non-intuitive, though, and could be difficult 
for programmers to find on their own. 


% We set out to build an enumerative synthesis tool that . 
% TODO this paragraph needs to be worded better.
We present \textsc{Petsy}, a tool that allows users to provide a type signature and 
optional examples, and get back a code snippet 
that consists of a composition of Haskell library functions. This allows
users to speed up their programming by using our tool to synthesize small 
Haskell programs instead of doing it themselves. 




\section{Related Work}

The problem we are exploring is polymorphic type-guided synthesis via 
enumerative search. Related problems have been explored before. 

\vspace{2mm}
\noindent \textbf{\textit{MYTH.}} \textsc{Myth} \cite{myth}
already explores enumerative search for 
type-directed synthesis, but it does not support polymorphism or typeclasses 
like we'd like \textsc{Petsy} to. 

\vspace{2mm}
\noindent \textbf{\textit{\textsc{Tygar}.}} \textsc{Tygar} \cite{tygar} uses Petri nets to 
tackle type-guided Haskell program synthesis, and is remarkable in that 
it also supports polymorphic types, typeclasses, and can check 
user-provided input-output examples. Because of its use of Petri nets, 
however, it has to reduce everything to first order, meaning that 
it can't make use of lambdas, which limits the space of programs that
\textsc{Tygar} can pull from.

\vspace{2mm}
\noindent \textbf{\textit{SYNQUID.}} \textsc{Synquid} \cite{synquid} makes 
use of an enumerative search approach, lambdas, and polymorphism. 
Its type system, however, restricts type variables
from unifying with arrow types. This prevents, for example, 
\texttt{Maybe} ${a \to a}$ 
and ${\alpha_1 \to \alpha_0 \to b}$ from unifying, even though in theory
they could if \texttt{Maybe} $a$ unified with $\alpha_1$, and $a$ unfied 
with $\alpha_0 \to b$. This leads to some programs being unreachable
and, in the context of higher-order components, limits the search space. 



\section{Approach}
\label{approach}



\subsection{Synthesis Problem}

Our synthesis \textit{problem} consists of a component library, a query type,
and optional input-output examples. A \textit{solution} to the synthesis 
problem is a Haskell code snippet that has the desired type and works 
for the optionally given examples.


% \subsection{Limitations with \textsc{Synquid}'s enumeration strategy}
\subsection{Extending \textsc{Synquid}'s enumeration strategy} 
% TODO thoughts on this section title change? 

\textsc{Petsy} builds upon \textsc{Synquid}, which solves its synthesis task 
by performing a top-down enemerative search and taking advantage of
refinement types that are included in the initial type query. 

\textsc{Synquid} synthesizes function applications in the following way. 
Given a goal $?? :: T$ that is an application, split it into two 
goals for the function and argument: $(?? :: \alpha \to T)$ and 
$(?? :: \alpha)$. Repeating this process in the first goal lets us 
use functions that take in more arguments:

\[ (?? :: \alpha_0 \to T) (?? :: \alpha_0) \]
\[ (?? :: \alpha_1 \to \alpha_0 \to T) (?? :: \alpha_1) (?? :: \alpha_0) \]
\[ (?? :: \alpha_2 \to \alpha_1 \to \alpha_0 \to T) (?? :: \alpha_2) (?? :: \alpha_1) (?? :: \alpha_0) \]

This could repeat forever. To ensure search terminates, the components 
decide the cutoff point: if the longest arrow type in the components is 
$a \to b \to c \to d$, then we stop splitting the goal once we see 
$\alpha_2 \to \alpha_1 \to \alpha_0 \to T$.

However, this approach fails when type variables are instantiated with 
arrow types. One concrete example is the query $(a \to b, a) \to b$ 
with components $[\texttt{fst}, \texttt{snd}]$. The solution is 
\texttt{fst p (snd p)}, which uses \texttt{fst} as a two-argument function, 
which means \texttt{fst} must have filled the goal $\alpha_1 \to \alpha_0 \to T$. 
However, \texttt{fst} and \texttt{snd} are one-argument functions -- 
the cutoff is $\alpha_0 \to T$, so we never end up considering the goal 
$\alpha_1 \to \alpha_0 \to T$.

Our solution is to use iterative deepening on the size of programs, 
rather than depth first search. Because we only enumerate programs up 
to a certain size anyways, we can be rid of the decision of ``where to 
stop splitting the goal''.

We also replace the measure of program size with ``number of components'' 
rather than ``recursion depth'', because size tends to generate deeper 
programs earlier, and deep programs like \texttt{f (g (h x))} tend to 
be more programmer-relevant than flat programs.



\subsection{Memoization (caching subproblems during enumeration)}

Because of its enumerative and iterative deepening qualities, \textsc{Petsy} 
generates many repeated subproblems
over the course of the search, wasting a lot of time redoing searches it has
already done. This makes memoization crucial to practical 
top-down enumeration, which \textsc{Myth} \cite{myth} was able to solve in a 
first-order setting.
In our polymorphic context, however, memoization is non-trivial. 
With polymorphism, goal types can contain free 
type variables. This causes a couple issues:

\begin{enumerate}
  \item \textbf{Type unificiation clashes:} With free type variables as
        goals, each cached program could cause the
        type variable to unify with a different type. For example,
        if the goal is $\alpha_0 \to Int$, two possible solutions
        are: \verb|length|, which has type $\forall \alpha . [\alpha] \to Int$,
        resulting in $\alpha_0$ and $[\alpha]$ being unified, and 
        \verb|incr|, which has type $Int \to Int$,
        resulting in $\alpha_0$ and $Int$ being unified. How do we ensure 
        that this won't cause any clashes when retrieving the problems from 
        the memo map when later trying to synthesize component arguments?
  \item \textbf{Redundancy:} At different points in the search, the free
        variables will have different names. This means two different goals,
        $\alpha_0 \to Int$ and $\alpha_1 \to Int$ would be syntactically different
        but semantically equivalent. How do we avoid storing the same code 
        snippets in multiple locations? 
\end{enumerate}

To resolve the first issue, we rename any incoming free type variables 
to be "fresh" before using them as the map lookup key. That way, if 
two different goals with free variables come in, say $\alpha_0 \to Int$ and 
$\alpha_1 \to Int$, they will each be renamed to $\beta_0 \to Int$ 
and $\beta_0 \to Int$, meaning that they will hit the same entry in the map,
despite having different original names.

To resolve the second issue, we use type inference to infer the type of 
the retrieved programs as if it was an existing component. For example, if we
retrieve a program \verb|length|, 

... . % TODO explain how this works. 
Similarly, if we retrieve a program \verb|incr|, 
... . % TODO explain how this works.
% TODO bring it all together to explain how it fixes issue.

% table of data 
\input{results}




\section{Results}



% TODO make sure that this is correct (where queries are from)
% TODO say how many components are used in the tests
We tested our results on 20 queries, that were based on the queries 
from \textsc{Tygar}'s \cite{tygar} paper and ${\lambda^2}$ \cite{lambda2}, and 
compared \textsc{Petsy} with \textsc{Tygar}, 
which is the tool that most resembles our own. The results can be found in 
Table \ref{tab:results}.


% \subsection{\textsc{Tygar} vs. Memoization}
\vspace{2mm}
\noindent \textbf{\textit{Analysis.}} 
% TODO re-write this once we have more accurate test bench
\textsc{Tygar} did better than \textsc{Petsy} in (TODO) out of the 20 tests. 
For most of the tests, the difference between the 2 tools is quite small. There
are additionally some tests that we do much better in (TODO list them)
and some tests that we do much worse in (TODO list them).
Test \#(TODO) shows how we are able to synthesize lambdas whereas \textsc{Tygar} cannot.

These results are quite encouraging. For one, since \textsc{Petsy} takes advantage of 
lambdas and \textsc{Tygar} doesn't, \textsc{Petsy} is more expressive and therefore searches through 
more programs, yet is still competitive. We also have only implemented the most
basic form of memoization, and plan to improve upon it to make \textsc{Petsy} even
faster (see \nameref{future}).

\vspace{2mm}
\noindent \textbf{\textit{Quality of Results.}} For the most part, both \textsc{Tygar} 
and \textsc{Petsy} returned the same programs. If they didn't return the same program,
the programs were equivalent, so the differences between the results of the two
tools is insignificant. 

\section{Future Work}
\label{future}

Our memoization tool is still very basic and we think there are multiple ways in
which we can improve upon what we have:

\begin{enumerate}
  \item Re-organize our memo map to store programs first based on size, and then 
        find programs based on query. This would make lookup much faster.
  \item Take advange of sub-typing in the memo keys so that the same programs
        aren't stored multiple times. For example, all programs in goal 
        $Int \to Int$ should be in goal $\alpha_0 \to Int$. When
        we lookup $\alpha_0 \to Int$, we could first look at $Int \to Int$
        and then move on to other programs that are more general.
  % \item Explore different ways of calculating program size to see if there is 
  %       size calculation that prioritizes more desired programs. As example would be 
  %       assigning more weight to programs with uninstantiated type variables 
\end{enumerate}

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base} 



\end{document}
\endinput
%%
%% End of file `sample-acmlarge.tex'.
